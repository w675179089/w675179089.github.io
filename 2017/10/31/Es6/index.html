<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Es6 | 小生有话说</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="let和const命令1. let命令 基本用法Es6 新增了let命令 用来声明变量。用法类似Es5的var 但是其所声明的变量 只在let命令所在的代码快内有效123456&amp;#123; let a = 10; var b = 10;&amp;#125;a //报错 not definedb //1 分别用let 和 var 声明的变量 在代码快之外调用 只有var是正确的 因为 let只在它所在的代码">
<meta property="og:type" content="article">
<meta property="og:title" content="Es6">
<meta property="og:url" content="http://yoursite.com/2017/10/31/Es6/index.html">
<meta property="og:site_name" content="小生有话说">
<meta property="og:description" content="let和const命令1. let命令 基本用法Es6 新增了let命令 用来声明变量。用法类似Es5的var 但是其所声明的变量 只在let命令所在的代码快内有效123456&amp;#123; let a = 10; var b = 10;&amp;#125;a //报错 not definedb //1 分别用let 和 var 声明的变量 在代码快之外调用 只有var是正确的 因为 let只在它所在的代码">
<meta property="og:locale" content="Chinese">
<meta property="og:updated_time" content="2017-11-07T09:25:40.375Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Es6">
<meta name="twitter:description" content="let和const命令1. let命令 基本用法Es6 新增了let命令 用来声明变量。用法类似Es5的var 但是其所声明的变量 只在let命令所在的代码快内有效123456&amp;#123; let a = 10; var b = 10;&amp;#125;a //报错 not definedb //1 分别用let 和 var 声明的变量 在代码快之外调用 只有var是正确的 因为 let只在它所在的代码">
  
    <link rel="alternate" href="/atom.xml" title="小生有话说" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小生有话说</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Es6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/31/Es6/" class="article-date">
  <time datetime="2017-10-31T06:42:45.000Z" itemprop="datePublished">2017-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Es6
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h1><h3 id="1-let命令"><a href="#1-let命令" class="headerlink" title="1. let命令"></a>1. let命令</h3><hr>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>Es6 新增了let命令 用来声明变量。用法类似Es5的var 但是其所声明的变量 只在let命令所在的代码快内有效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> let a = 10;</div><div class="line"> var b = 10;</div><div class="line">&#125;</div><div class="line">a //报错 not defined</div><div class="line">b //1</div></pre></td></tr></table></figure></p>
<p>分别用let 和 var 声明的变量 在代码快之外调用 只有var是正确的 因为 let只在它所在的代码块有效</p>
<p>for 循环的计数器 很适合用let 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(let i =0; i&lt;10;i++)&#123;</div><div class="line">//</div><div class="line">&#125;</div><div class="line">console.log(i) // not defined 拿不到i 只在for循环内有效</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>var 出来的变量会发生变量提升 即变量可以在声明之前使用<br>let 的变量不行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// var 的情况</div><div class="line">console.log(a) // 2</div><div class="line">var a = 2;</div><div class="line">// let 的情况</div><div class="line">console.log(b) //报错</div><div class="line">let b = 1;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>  只要快级作用域内存在let命令 它所声明的变量就“绑定”了这个区域，不再受外部的影响<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var tmp =&apos;123&apos;;</div><div class="line">if(true)&#123;</div><div class="line"> tmp = &apos;dwa&apos;; //报错</div><div class="line"> let tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然存在var声明的全局变量tmp 但是if内部又let一个局部变量tmp<br>导致这个tmp绑定了这个if内的作用域 所以在let声明变量前 tmp报错<br>总之在代码快内 使用let命令声明变量之前该变量都是不可用的 这在语法上称为“暂时性死区”</p>
<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p>let 不允许在相同的作用域内 重复声明同一个变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//报错</div><div class="line"> function func()&#123;</div><div class="line">  let a = 10;</div><div class="line">  var a =1; </div><div class="line"> &#125;</div><div class="line"> //报错</div><div class="line"> function func()&#123;</div><div class="line">  let a = 10;</div><div class="line">  let a = 1; </div><div class="line"> &#125;</div><div class="line"> // 不能在函数内部重新声明参数</div><div class="line">  function (arg)&#123;</div><div class="line">  	let arg;//报错</div><div class="line">  	&#123;</div><div class="line">  		left arg;//不报错</div><div class="line">  	&#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-块级作用域"><a href="#2-块级作用域" class="headerlink" title="2. 块级作用域"></a>2. 块级作用域</h3><h3 id="为什么需要块级作用域"><a href="#为什么需要块级作用域" class="headerlink" title="为什么需要块级作用域"></a>为什么需要块级作用域</h3><p>ES5 只有在全局作用域和函数作用域 没有块级作用域 这带来很多不合理的场景<br>the one 内层变量覆盖外层变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var tmp = new Date();</div><div class="line"> function f()&#123;</div><div class="line">  console.log(tmp);</div><div class="line">  if(false)&#123;</div><div class="line">  	var tmp = &apos;321&apos;</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> f() //undefined;</div></pre></td></tr></table></figure></p>
<p>ES6 的块级作用域<br>let 实际上为JavaScript 新增了跨级作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function f1()&#123;</div><div class="line">	let n = 5;</div><div class="line">	if(true)&#123;</div><div class="line">	let n = 10;</div><div class="line"> &#125;</div><div class="line"> 	console.log(n) //5</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中都声明了n 但是因为块级作用域的存在 外层代码不受内层影响<br>如果都是var 声明的 则是10；<br>ES6 允许跨级作用域的任意嵌套<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&#123;&#123;&#123;&#123;&#123;let name=&apos;wang&apos;&#125;&#125;&#125;&#125;&#125;&#125;&#125;</div><div class="line">&#123;&#123;&#123;&#123;&#123;&#123;</div><div class="line">	&#123;let one =&apos;1&apos;&#125;</div><div class="line">	console.log(one)//报错</div><div class="line">	&#125;&#125;&#125;&#125;&#125;&#125;</div><div class="line">&#123;&#123;&#123;&#123;&#123;&#123;</div><div class="line">	&#123;let one =&apos;1&apos;&#125;</div><div class="line">	let one =&apos;2&apos;</div><div class="line">	&#125;&#125;&#125;&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>——————————————————————————————————————</p>
<h3 id="3-const-命令"><a href="#3-const-命令" class="headerlink" title="3. const 命令"></a>3. const 命令</h3><hr>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>const 声明一个只读的常量。一旦声明 常量的值就不能改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const PI = 3.1415;</div><div class="line">PI//3.1415</div><div class="line">PI = 3 //报错</div></pre></td></tr></table></figure></p>
<p>const 声明的变量不得改变值 这意味着 一旦声明变量 就必须立即初始化 不能留到以后赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const foo;</div><div class="line">//报错 要立即初始化;</div></pre></td></tr></table></figure></p>
<p>const 的作用域与let命令相同 只在声明所在的块级作用域内有效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if(true)&#123;</div><div class="line"> const max =5;</div><div class="line">&#125;</div><div class="line">max //报错 not defined;</div></pre></td></tr></table></figure></p>
<p>此外 const命令的变量与let变量一致（不可重复声明，不存在变量提升存在暂时性死区）</p>
<h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><h3 id="1-数组得到解构赋值"><a href="#1-数组得到解构赋值" class="headerlink" title="1. 数组得到解构赋值"></a>1. 数组得到解构赋值</h3><hr>
<h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>es6 允许按照一定模式 从数组和对象中提取值 对变量进行赋值 这被称为解构<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [a,b,c] = [1,2,3];</div></pre></td></tr></table></figure></p>
<p>按照对应位置 对变量进行赋值<br>下面是一些常见的使用嵌套数组进行解构的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">let [foo,[[bar],baz]] = [1,[[2],3]]</div><div class="line">foo //1;</div><div class="line">bar //2</div><div class="line">baz //3</div><div class="line"></div><div class="line">let [,,third] = [&apos;foo&apos;,&apos;bar&apos;,&apos;baz&apos;]</div><div class="line">third // &apos;baz&apos;;</div><div class="line"></div><div class="line">let [x,,y] = [1,2,3]</div><div class="line">x //1;</div><div class="line">y //3;</div><div class="line"></div><div class="line">let [hear,...tail] = [1,2,3]</div><div class="line">hear //1;</div><div class="line">tail [2,3]</div><div class="line"></div><div class="line">let [x,y,...z] = [&apos;a&apos;];</div><div class="line">x //a;</div><div class="line">y //undefined;</div><div class="line">z //[];</div><div class="line"></div><div class="line">let [foo] = [];</div><div class="line">let [bar,foo] = [1];</div></pre></td></tr></table></figure></p>
<p>以上最后两种情况解构不成功 就是undefined；</p>
<p>还有不完全解构 即左边的只匹配部分右边的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let [x,y] = [1,2,3]</div><div class="line">x //1;</div><div class="line">y //2;</div><div class="line"></div><div class="line">let [a,[b],d] = [1,[2,3],4]</div><div class="line">a //1;</div><div class="line">b //2</div><div class="line">d //4</div></pre></td></tr></table></figure></p>
<p>如果等号右边不是数组 或者不是严格可遍历的解构 那么将会报错</p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let [foo = true] = [];</div><div class="line">foo //true;</div><div class="line"></div><div class="line">let [x,y = &apos;b&apos;] = [&apos;a&apos;]; // x =&apos;a&apos; , y = &apos;b&apos;;</div><div class="line">let [x,y = &apos;b&apos;] = [&apos;a&apos;,undefined] // x=&apos;a&apos; y =&apos;b&apos;</div></pre></td></tr></table></figure>
<p>ES6 内部使用严格相等运算符（===）判断一个位置是否有值。所以 如果一个数组成员不严格等于undefined 默认值不会生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [x = 1] = [undefined] // x= 1;</div><div class="line">let [ x = 1] = [null]  // x为null</div></pre></td></tr></table></figure></p>
<p>如果一个数组成员是null 默认值不会生效 一万null 不严格等于undefined</p>
<p>默认值可以引用解构的其他变量 但该变量必须已经声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [x = 1, y = x] = [] //x=1,y=1;</div><div class="line">let [x = y, y = 1] = [] //报错 因为y后声明</div></pre></td></tr></table></figure></p>
<h3 id="2-对象的解构赋值"><a href="#2-对象的解构赋值" class="headerlink" title="2.对象的解构赋值"></a>2.对象的解构赋值</h3><p>同理 解构 可以用于对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let &#123;foo,bar&#125; = &#123;foo:&apos;aaa&apos;,bar:&apos;bbb&apos;&#125; </div><div class="line">foo // &apos;aaa&apos;;</div><div class="line">bar // &apos;bbb&apos;;</div><div class="line"></div><div class="line">let &#123;baz&#125; = &#123;foo:&apos;aaa&apos;,bar:&apos;bbb&apos;&#125;</div><div class="line">baz //undefined;</div></pre></td></tr></table></figure></p>
<p>对象的解构 与数组的解构不同数组的元素按次序取值 即某个位置取对应位置的值<br>而对象的属性没有次序 变量必须与属性同名才能取到正确的值 如上面最后一例</p>
<p>对象的解构赋值的内部机制 是先找到同名属性 然后再赋值给对应的变量 真正被赋值的是后者 而不是前者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> let &#123;foo:baz&#125; = &#123;foo:&apos;aaa&apos;,bar:&apos;bbb&apos;&#125;;</div><div class="line"> 	baz //&apos;aaa&apos;</div><div class="line">foo // not defined;</div></pre></td></tr></table></figure></p>
<p>上面大代码中 foo是匹配的模式 baz才是变量 真正被赋值的是变量baz<br>而不是模式foo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;p:[&apos;hello&apos;,&#123;y:&apos;world&apos;&#125;]&#125;;</div><div class="line">let &#123;p,p:[x,&#123;y&#125;]&#125; =obj;</div><div class="line">x //&apos;hello&apos;;</div><div class="line">y // &apos;world&apos;;</div><div class="line">p //[&apos;hello&apos;,&#123;y:&apos;world&apos;&#125;]</div></pre></td></tr></table></figure>
<p>第一个p是变量 所以一次匹配值是数组 第二p是匹配模式</p>
<p>对象的解构也可以指定默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var &#123;x = 3&#125; = &#123;&#125;</div><div class="line">x //3;</div><div class="line"></div><div class="line">var &#123;x,y = 5&#125; = &#123;x:1&#125;;</div><div class="line">x //1;</div><div class="line">y //5;</div></pre></td></tr></table></figure></p>
<p>默认值生效的条件是 对象的属性值 严格等于undefined</p>
<p>如果讲一个已经声明的变量用于解构赋值 必须非常小心<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let x;</div><div class="line">&#123;x&#125; = &#123;x:1&#125; //报错</div><div class="line">(&#123;x&#125; = &#123;x:1&#125;) //正确</div></pre></td></tr></table></figure></p>
<h3 id="3-字符串的解构赋值"><a href="#3-字符串的解构赋值" class="headerlink" title="3. 字符串的解构赋值"></a>3. 字符串的解构赋值</h3><p>字符串也可以解构赋值 这是因为此时 字符串 被转换成了一个类似的数组的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const [a,b,c,d] = &apos;hello&apos;;</div><div class="line">a //h;</div><div class="line">b //e;</div><div class="line">c //l;</div><div class="line">d //l</div></pre></td></tr></table></figure></p>
<p>类似数组的对象都有一个length属性 因此还可以对这个属性解构赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let &#123;length :len&#125; = &apos;hello&apos;;</div><div class="line">len //5;</div></pre></td></tr></table></figure></p>
<h3 id="4-数值和布尔值的解构赋值"><a href="#4-数值和布尔值的解构赋值" class="headerlink" title="4. 数值和布尔值的解构赋值"></a>4. 数值和布尔值的解构赋值</h3><p>解构赋值时 如果等号右边是数值和布尔值 则会先转为对像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let &#123;toString : s&#125; = 123;</div><div class="line"> s === Number.prototype.toString // true;</div></pre></td></tr></table></figure></p>
<h3 id="5-函数参数的解构赋值"><a href="#5-函数参数的解构赋值" class="headerlink" title="5.函数参数的解构赋值"></a>5.函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function add([x,y])&#123;</div><div class="line">	return x+y;</div><div class="line">&#125;</div><div class="line">add([1,2]) //3</div></pre></td></tr></table></figure></p>
<h3 id="6-圆括号的问题"><a href="#6-圆括号的问题" class="headerlink" title="6.圆括号的问题"></a>6.圆括号的问题</h3><p>一下三种解构赋值不能使用圆括号<br>(1) 变量声明语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//报错</div><div class="line">let [(a)] = [1];</div><div class="line">let &#123;x:(c)&#125; =&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>(2) 函数参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//报错</div><div class="line">function f([(z)])&#123;return z&#125;;</div><div class="line">function f([z,(x)])&#123;return x&#125;;</div></pre></td></tr></table></figure>
<p>(3) 赋值语句的模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(&#123;p:a&#125;) = &#123;p:42&#125;;</div><div class="line">([a]) = [5];</div></pre></td></tr></table></figure></p>
<h3 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[(b)] = [3]</div><div class="line">(&#123;p:(d)&#125; = &#123;&#125;)</div><div class="line">[(parseInt.prop)] = [3]</div></pre></td></tr></table></figure>
<p>上面都能正确执行 因为他们是赋值语句 而不是声明语句<br>其次他们的圆括号都不属于模式的一部分</p>
<h3 id="7-用途"><a href="#7-用途" class="headerlink" title="7.用途"></a>7.用途</h3><p>  1.交换变量的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let x =1;</div><div class="line">let y =2;</div><div class="line">[x,y] =[y,x]</div></pre></td></tr></table></figure></p>
<p>  2.从函数返回多个值<br>  函数只能返回一个值 如果非要返回多个值 只能将他们放在数组或对象里返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//返回一个数组</div><div class="line">  funxtion ex()&#123;</div><div class="line">  	return [1,2]</div><div class="line">  &#125;</div><div class="line">  let [a,b] = ex()</div><div class="line">  //返回对象</div><div class="line">  function obj()&#123;</div><div class="line">   return &#123;foo:1,bar:2&#125;</div><div class="line">  &#125;;</div><div class="line">  let &#123;foo,bar&#125; = ex()</div></pre></td></tr></table></figure></p>
<p>3.函数参数的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function f([x,y,z])&#123;&#125;</div><div class="line">f([1,2,3]);</div></pre></td></tr></table></figure></p>
<p>4.提取json数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let data =&#123;id:42,status:&apos;ok&apos;&#125;;</div><div class="line">let &#123;id,status&#125; = data;</div></pre></td></tr></table></figure></p>
<h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><h3 id="字符串的遍历接口"><a href="#字符串的遍历接口" class="headerlink" title="字符串的遍历接口"></a>字符串的遍历接口</h3><p>  for…of<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for(let str og &apos;foo&apos;)&#123;</div><div class="line">	console.log(str)</div><div class="line">&#125;</div><div class="line">//&apos;f&apos;</div><div class="line">//&apos;o&apos;</div><div class="line">//&apos;o&apos;</div></pre></td></tr></table></figure></p>
<h3 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h3><p>es5对字符串对象提供的charAt方法 返回字符串给定位置的字符<br>该方法不能识别码点大于0xFFFF的字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;abc&apos;.charAt(0) //&apos;a&apos;</div><div class="line">&apos;𠮷&apos;.charAt(0) // &quot;\uD842&quot;</div></pre></td></tr></table></figure></p>
<p>上面的代码 charAt返回的是UTF-16编码的第一个字节 实际上是无法显示的。<br>可以用at()识别Unicode编号大于0xFFFF的字符，返回正确的字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;abc&apos;.at(0) //&apos;a&apos;</div><div class="line"> &apos;𠮷&apos;.charAt(0) // &quot;𠮷&quot;</div></pre></td></tr></table></figure></p>
<h3 id="includes-startsWidth-endsWidth"><a href="#includes-startsWidth-endsWidth" class="headerlink" title="includes() startsWidth() endsWidth()"></a>includes() startsWidth() endsWidth()</h3><p>传统上 JavaScript只有indeOf()方法 可以用来确定一个字符串是否包含在另一个字符换中 ES6又提供了 三种新方法<br>includes():返回布尔值 便是是否找到了参数字符串<br>startsWidth():返回布尔值 表示参数字符串是否在原字符串的头部<br>endsWidth():返回布尔值 表示参数字符串是否在原字符串的尾部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let s = &apos;hello world!&apos;;</div><div class="line">s.startsWidth(&apos;hello&apos;) //true;</div><div class="line">s.ensWidth(&apos;!&apos;) // true;</div><div class="line">s.includes(&apos;o&apos;) //true;</div></pre></td></tr></table></figure></p>
<p>这三个方法都支持第二个参数 表示开始搜索的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let s = &apos;hello world!&apos;;</div><div class="line">s.startsWidth(&apos;world&apos;,6) //true</div><div class="line">s.endsWidth(&apos;hello&apos;,5) //true</div><div class="line">s.includes(&apos;hello&apos;,6) //false;</div></pre></td></tr></table></figure></p>
<p>当使用第二个参数时（n） endsWidth() 表示到第n个结束 其余两个表示从第n个开始知道结束；</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>  repeat方法返回一个新字符串 表示将原字符串重复n次<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&apos;x&apos;.repeat(3) // &apos;xxx&apos;</div><div class="line">&apos;hello&apos;.repeat(2) /&apos;hellohello&apos;</div><div class="line">&apos;na&apos;.repeat(0) //&apos;&apos;</div></pre></td></tr></table></figure></p>
<p>  参数如果是小数 会被取整 如果是负数或infinity 会报错<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;na&apos;.repeat(2.9) //&apos;nana&apos;</div><div class="line">&apos;na&apos;.repeat(-1) //报错</div></pre></td></tr></table></figure></p>
<p>  如果是0——-1之间的数  会取证为0 NaN视为0 如果是字符串数字 先转成数字<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&apos;na&apos;.repeat(&apos;na&apos;) //等同于0 所以结果为 &quot;&quot;</div><div class="line">&apos;na&apos;.repeat(&apos;3&apos;) //&apos;nanana&apos;</div><div class="line">&apos;na&apos;.repeat(-0.1) //&quot;&quot;</div></pre></td></tr></table></figure></p>
<h3 id="padStart-padEnd"><a href="#padStart-padEnd" class="headerlink" title="padStart() padEnd()"></a>padStart() padEnd()</h3><p>  es6 引入了字符串补全长度的功能 如果某个字符串不够指定长度 会在头部或尾部补全<br>  padStart() 用于头部补全 padEnd() 用于尾部补全<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;x&apos;.padStart(5,&apos;ac&apos;) //acacx</div><div class="line">&apos;x&apos;.padStart(&apos;4&apos;,&apos;ab&apos;) //&apos;abax&apos;</div><div class="line"></div><div class="line">&apos;x&apos;.padEnd(5,&apos;ab&apos;) //xabab;</div><div class="line">&apos;x&apos;.padEnd(4,&apos;ab&apos;) //xaba</div></pre></td></tr></table></figure></p>
<p>  这两个方法一共接受两个参数 第一个参数用来指定字符串的最小长度 第二个参数是用来补全的字符串<br>  如果原字符串的长度 等于或大于指定的最小长度 则返回原字符串<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;xxx&apos;.padStart(2,&apos;ab&apos;) //xxx</div></pre></td></tr></table></figure></p>
<p>  如果用来补全的字符换与原字符串 两者的长度之和超过了指定的最小长度 则会截去超出位数的补全字符串<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;abc&apos;.padStart(10,&apos;0123456789&apos;) //0123456abc</div></pre></td></tr></table></figure></p>
<p>  如果省略第二个参数 默认使用空格补全长度<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;x&apos;.padStart(4) //&apos;   x&apos;</div></pre></td></tr></table></figure></p>
<p>  padStart() 的常见用途是为数值补全指定位数 下面代码生成10位的数值字符串<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;1&apos;.paddStart(10,&apos;0&apos;)//&apos;0000000001&apos;</div><div class="line">&apos;12&apos;.padStart(10,&apos;0&apos;) //&apos;0000000012&apos;</div></pre></td></tr></table></figure></p>
<p>  另一个用途是提示字符串<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;12&apos;.padStart(10,&apos;YYYY-MM-DD&apos;) //&apos;YYYY-MM-12&apos;</div><div class="line">&apos;09-12&apos;.paddStart(10,&apos;YYYY-MMDD&apos;) //&apos;YYYY-09-12&apos;</div></pre></td></tr></table></figure></p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(obj).append(`</div><div class="line">   there are &lt;br&gt;$&#123;basket.count&#125;&lt;/b&gt; items in...&lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;</div><div class="line">`)</div></pre></td></tr></table></figure>
<p>  用反引号(`)标识 他可以当做普通字符串使用 也可以用来定义多行字符串 或者在字符串中嵌入变量<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> //普通字符串</div><div class="line"> `In javascript &apos;\n&apos; is a line-feed.`</div><div class="line"> //多行字符串</div><div class="line"> `in javascript this is</div><div class="line"> not legal`</div><div class="line"> console.log(`this is line 1</div><div class="line"> this is line 2`)</div><div class="line"> // 字符串嵌入变量</div><div class="line"> let name = &apos;Bob&apos;,time = &apos;today&apos;</div><div class="line"> `hellow $&#123;name&#125;, how are you $&#123;time&#125;`</div><div class="line">//用到反引号的时候用反斜杠转义</div><div class="line"> let greeting = `\`Yo\` World!`;</div></pre></td></tr></table></figure></p>
<p>  用反引号格式化的字符串保留空格和缩进<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(obj).append(`</div><div class="line">  &lt;ul&gt;</div><div class="line">  &lt;/ul&gt;</div><div class="line">`.trim())</div></pre></td></tr></table></figure></p>
<p>  如不想保留换行空格 可用trim()消除;<br>  模板字符串嵌入变量 需要将变量名写在${}中<br>  大括号内部可以放入任意的JavaScript表达式 可以进行运算以及引用对象属性<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let x = 1;</div><div class="line">let y = 2;</div><div class="line">`$&#123;x&#125;+$&#123;y&#125; = $&#123;x+y&#125;` // &quot;1+2=5&quot;</div><div class="line">let obj= &#123;x:1,y:2&#125;</div><div class="line">`$&#123;obj.x+obj.y&#125;`</div></pre></td></tr></table></figure></p>
<p>  模板字符串还能调用函数<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function fn()&#123;</div><div class="line">  return &quot;hello world&quot;;</div><div class="line">&#125;</div><div class="line">`foo $&#123;fn()&#125; bar` // foo hello world bar</div></pre></td></tr></table></figure></p>
<h1 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h1><h3 id="1-regexp-的构造函数"><a href="#1-regexp-的构造函数" class="headerlink" title="1. regexp 的构造函数"></a>1. regexp 的构造函数</h3><p>  如果regexp构造函数第一参数是一个正则对象 那么可以使用第二个参数指定修饰符 而且 返回的正则表达式会忽略原有的正则表达式的修饰符 只使用新指定的修饰符<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new RegExp(/abc/ig,&apos;i&apos;).flags</div></pre></td></tr></table></figure></p>
<p>  上面代码中 原有的正则对象的修饰符是ig 它会被第二个参数i覆盖</p>
<h3 id="2-字符串的正则方法"><a href="#2-字符串的正则方法" class="headerlink" title="2. 字符串的正则方法"></a>2. 字符串的正则方法</h3><p>  共有四个方法 match() replace() search() split()<br>  es6 将这4个方法 在语言内部全部调用regexp 的实例方法 从而做到所有与正则相关的方法 全部定义在regexp对象上</p>
<pre><code>String.prototype.match 调用 RegExp.prototype[Symbol.match]
String.prototype.replace 调用 RegExp.prototype[Symbol.replace]
String.prototype.search 调用 RegExp.prototype[Symbol.search]
String.prototype.split 调用 RegExp.prototype[Symbol.split]
</code></pre><h3 id="3-U修饰符"><a href="#3-U修饰符" class="headerlink" title="3.U修饰符"></a>3.U修饰符</h3><p>  ES6 对正则表达式添加了u修饰符 含义为”Unicode模式” 用来正确处理大于 \uFFFF的unicode字符 也就是说 会正确处理四个字节的UTF-16的编码<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/^\uD83D/u.test(&apos;\uD83D\uDC2A&apos;) //false</div><div class="line">/^\uD83D/.test(&apos;\uD83D\uDC2A&apos;) //true</div></pre></td></tr></table></figure></p>
<p>  因为es5不支持四个字节的UTF-16编码 所以第二行只能认识\uD83D 返回true<br>  es6加了u识别四字节编码 所以第一行为false</p>
<p>  (1).点字符<br>  点(.)字符在正则表达式中 含义是除了换行符以外的任意单个字符 对于码点大于0xFFFF的Unicode字符 点字符不能识别 必须加上U字符。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s = &apos;𠮷&apos;</div><div class="line"></div><div class="line">/^.$/.test(s) //false;</div><div class="line">/^.$/u.test(s) //true;</div></pre></td></tr></table></figure></p>
<p>  上面代码表示 如果不添加u修饰符 正则表达式就会认为字符串为两个字符 从而匹配失败</p>
<p>  (2) Unicode字符表示法<br>  es6新增了使用大括号表示的Unicode字符 这种表示法在正则表达式中必须加上u修饰符 才能识别当中的大括号 否则会被解读为量词<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/\u&#123;61&#125;/.test(&apos;a&apos;) //false</div><div class="line">/\u&#123;61&#125;/u.test(&apos;a&apos;) //true;</div><div class="line">/\u&#123;20BB7&#125;/u.test(&apos;𠮷&apos;) //true</div></pre></td></tr></table></figure></p>
<p>  上面代码表示 如果不加u修饰符无法识别\u{61} 只会认为这匹配61个连续的u</p>
<p>  (3). 量词<br>  使用U修饰符后 所有的量词都会正确识别码点大于0xFFFF的unicode字符<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/a&#123;2&#125;/.test(&apos;aa&apos;) //true</div><div class="line">/a&#123;2&#125;/u.test(&apos;aa&apos;)  //true</div><div class="line">/𠮷&#123;2&#125;/.test(&apos;𠮷𠮷&apos;) //false</div><div class="line">/𠮷&#123;2&#125;/u.test(&apos;𠮷𠮷&apos;) //true</div></pre></td></tr></table></figure></p>
<h3 id="4-y修饰符"><a href="#4-y修饰符" class="headerlink" title="4.y修饰符"></a>4.y修饰符</h3><p>  除了u修饰符 es6还为正则表达式添加了y修饰符 叫做“粘连”修饰符<br>  y修饰符的作用与g修饰符类似 也是全局匹配 后一次匹配都从上一次匹配成功的下个位置开始 不同之处在于g只要在剩余位置中存在即可 而y修饰符确保必须从剩余的第一个位置开始<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var s = &apos;aaa_aa_a&apos;;</div><div class="line">var r1 = /a+/g</div><div class="line">var r2 = /a+/y</div><div class="line"></div><div class="line">r1.exec(s) //[&apos;aaa&apos;]</div><div class="line">r2.exec(s) //[&apos;aaa&apos;]</div><div class="line"></div><div class="line">r1.exec(s) //[&apos;aa&apos;]</div><div class="line">r2.exec(s) //null</div></pre></td></tr></table></figure></p>
<p>  当第一执行过后 s为’_aa<em>a’ g修饰符对位置没有要求 但是y要求匹配从头部开始 也就是第一个要为a不能是</em></p>
<h3 id="5-sticky属性"><a href="#5-sticky属性" class="headerlink" title="5. sticky属性"></a>5. sticky属性</h3><p>  与y修饰符相匹配 es6的正则对象多了sticky属性 表示是否设置了y修饰符<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var r = /hello/y;</div><div class="line">r.sticky //true;</div></pre></td></tr></table></figure></p>
<h3 id="6-flags属性"><a href="#6-flags属性" class="headerlink" title="6. flags属性"></a>6. flags属性</h3><p>  ```<br>  //es5的source属性 返回正则表达式的正文<br>  /abc/ig.source // ‘abc’</p>
<p>  //es6 的flags属性 返回正则表达式的修饰符<br>  /abc/ig.flags //gi<br>  ``</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/31/Es6/" data-id="cj9qppusw0000soydhpbmi4ia" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/10/26/my-new-post/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">初识Markdown</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/10/31/Es6/">Es6</a>
          </li>
        
          <li>
            <a href="/2017/10/26/my-new-post/">初识Markdown</a>
          </li>
        
          <li>
            <a href="/2017/10/26/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Wang XJ<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>